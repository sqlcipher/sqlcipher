# This file implements regression tests for SQLite library.  The
# focus of this script is testing code cipher features.
#
# codec.test developed by Stephen Lombardo (ZETETIC LLC) 
# sjlombardo@zetetic.net
#
# NOTE: tester.tcl has overridden the definition of sqlite3 to 
# automatically pass in a key value. Thus tests in this file
# should explicitly close and open db with sqlite_orig in order
# to bypass default key assignment.

file delete -force test.db
file delete -force test2.db

set testdir [file dirname $argv0]
source $testdir/tester.tcl

# If the library is not compiled with has_codec support then
# skip all tests in this file.
if {![sqlite_orig -has-codec]} {
  finish_test
  return
}

# The database is initially empty.
do_test codec-1.1 {
  sqlite_orig db test.db
  execsql {
    SELECT name FROM sqlite_master WHERE type='table';
  }
} {}

# set an encryption key and create some basic data
# create table and insert operations should work
do_test codec-1.2 {
  db close
  sqlite_orig db test.db
  execsql {
    PRAGMA key = 'testkey';
    CREATE table t1(a,b);
    INSERT INTO t1 VALUES ('test1', 'test2'); 
  }
} {}

# close database, open it again with the same
# key. verify that the table is readable
# and the data just inserted is visible
do_test codec-1.3 {
  db close
  sqlite_orig db test.db
  execsql {
    PRAGMA key = 'testkey';
    SELECT name FROM sqlite_master WHERE type='table';
    SELECT * from t1;
  }
} {t1 test1 test2}

# open the database and try to read from it without
# providing a passphrase. verify that the 
# an error is returned from the library
do_test codec-1.4 {
  db close
  sqlite_orig db test.db
  catchsql {
    SELECT name FROM sqlite_master WHERE type='table';
  }
} {1 {file is encrypted or is not a database}}

# open the database and try to set an invalid
# passphrase. verify that an error is returned
# and that data couldn't be read
do_test codec-1.5 {
  db close
  sqlite_orig db test.db
  catchsql {
    PRAGMA key = 'testkey2';
    SELECT name FROM sqlite_master WHERE type='table';
  }
} {1 {file is encrypted or is not a database}}

# open using raw hex key
do_test codec-1.6 {
  db close
  sqlite_orig db test.db
  execsql {
    PRAGMA key = "x'98483C6EB40B6C31A448C22A66DED3B5E5E8D5119CAC8327B655C8B5C4836489'";
    SELECT * from t1;
  }
} {test1 test2}

# test invalid hex key fails
do_test codec-1.7 {
  db close
  sqlite_orig db test.db
  catchsql {
    PRAGMA key = "x'98483C6EB40B6C31A448C22A66DED3B5E5E8D5119CAC8327B655C8B5C4836480'";
    SELECT name FROM sqlite_master WHERE type='table';
  }
} {1 {file is encrypted or is not a database}}

# test a large number of inserts in a transaction for multiple pages
do_test codec-1.8 {
  db close
  sqlite_orig db test.db
  execsql {
    PRAGMA key = 'testkey';
    BEGIN;
    CREATE TABLE t2(a,b);
  }
  for {set i 1} {$i<=25000} {incr i} {
    set r [expr {int(rand()*500000)}]
    execsql "INSERT INTO t2 VALUES($i,$r);" 
  }
  execsql {
    COMMIT;
    SELECT count(*) FROM t2;
  } 
} {25000}

# test initial rekey
do_test codec-1.9 {
  db close
  sqlite_orig db test.db
  execsql {
    PRAGMA key = 'testkey';
    PRAGMA rekey = 'testkeynew';
  }
  db close
} {}

# test that now the new key opens the database
# now close database re-open with new key
do_test codec-1.10 {
  sqlite_orig db test.db
  execsql {
    PRAGMA key = 'testkeynew';
    SELECT count(*) FROM t2;
  }
} {25000}


db close
finish_test
